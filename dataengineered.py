import pandas as pd

# Load the dataset
data = pd.read_csv('data/sensor_cleaned.csv', parse_dates=['timestamp'])

# Set timestamp as the index
data.set_index('timestamp', inplace=True)

# Choose your sensors
sensor_columns = [col for col in data.columns if 'sensor_' in col]

# Temporal feature engineering
windows = ['1H', '6H']  # Define window sizes for rolling statistics
lags = [1, 3]  # Define lags (adjust as per your sampling rate)

# Initialize a list to hold new feature DataFrames
new_features = []

# Rolling statistics
for window in windows:
    for sensor in sensor_columns:
        new_features.append(data[sensor].rolling(window=window).mean().rename(f'{sensor}_mean_{window}'))
        new_features.append(data[sensor].rolling(window=window).std().rename(f'{sensor}_std_{window}'))
        new_features.append(data[sensor].rolling(window=window).min().rename(f'{sensor}_min_{window}'))
        new_features.append(data[sensor].rolling(window=window).max().rename(f'{sensor}_max_{window}'))

# Lagged features
for lag in lags:
    for sensor in sensor_columns:
        new_features.append(data[sensor].shift(lag).rename(f'{sensor}_lag_{lag}'))

# Rate of change
for sensor in sensor_columns:
    new_features.append(data[sensor].diff().rename(f'{sensor}_roc'))

# Combine all new features using pd.concat
data = pd.concat([data] + new_features, axis=1)

# Drop NaN values generated by rolling and lagging
data.dropna(inplace=True)

# Save the engineered features to a new CSV file, if needed
data.to_csv('data/sensor_engineered.csv')

print("Temporal feature engineering complete. Head of the new dataset:")
print(data.head())
